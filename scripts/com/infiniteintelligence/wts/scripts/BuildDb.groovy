/**
 * This groovy script is used to rebuild the database from scratch. It executes the ddl created by schema-export, plus
 * any other SQL script that is listed in the 'ddl' list (e.g., indexes and any other object not created by Grails
 * in schema-export.)
 *
 * This script is run with 'run-script' as follows: [environment] run-script scripts/gov/epa/otaq/fuels/ffars/scripts/BuildDb.groovy
 */

package com.infiniteintelligence.wts.scripts

import grails.plugin.springsecurity.SpringSecurityUtils
import grails.util.Environment
import grails.util.Holders
import groovy.sql.Sql
import org.apache.commons.logging.LogFactory
import org.codehaus.groovy.grails.commons.GrailsApplication

import com.infiniteintelligence.wts.service.security.SecurityService
import com.infiniteintelligence.wts.security.*

// Script begins here:
main()

/**
 * Script's simulated main().
 */
def main() {

    // Get a logger, and make it a property of the script's class to make it available to all methods in the script.
    this.metaClass.log = LogFactory.getLog(getClass())
    log.info '---------- BuildDb.groovy: BEGIN -----------'
    log.info "Running script class '${this.class.name}' in package '${this.class?.package?.name}'"

    // Get an SQL instance, and make it a property of the script's class too.
    this.metaClass.sql = new Sql(ctx.dataSource)

    ConfigObject dataSourceConfig = Holders.config.dataSource

    printDataSourceConfig(dataSourceConfig)

    def currentDir = new File(".").getCanonicalPath()
    log.info "This script's current directory is $currentDir"

    def ddl = [
            // DDL generated by Grails from the domain classes:
            'grails-schema-export-ddl', // Run this script first!

            // Additional DDL that Grails did not generate
            // Listed by alphabetical order or logical groupings, unless dependencies between the scripts require a different order
            // (Please document any dependency)
    ]

    def views = [
    ]

    def procedures = [
    ]

    def metadata = [

            // Meta data (e.g., code tables)
            // Listed by alphabetical order, unless dependencies between the scripts require a different order
            // (Please document any dependency)
            'ThreatSeverityCode',
            'ThreatTypeCode'
    ]

    sql.withTransaction {

        // Drop all objects
        dropAllObjects()

        // Create the DDL:
        ddl.each { filename ->
            def script = "./db/ddl/${filename}.sql"
            log.info "Executing $script ..."
            int errorCount = executeSqlScriptByStatement(script)
            if (errorCount > 0) {
                throw new RuntimeException("The execution of $script encountered $errorCount error(s).")
            }
        }

        // Create the views
        views.each { filename ->
            String scriptFileName = "./db/ddl/views/${filename}.sql"
            log.info "Executing $scriptFileName ..."
            String scriptText = new File(scriptFileName).text
            sql.execute scriptText
        }

        // Create the procedures
        procedures.each { filename ->
            String scriptFileName = "./db/ddl/procedures/${filename}.sql"
            log.info "Executing $scriptFileName ..."
            String scriptText = new File(scriptFileName).text
            sql.execute scriptText
        }

//        createForeignKeyIndexes(dataSourceConfig.username)

        createRolesAndSystemAccount()

        createTestUsers()

        // Load the metadata from SQL scripts:
        metadata.each { table ->

            def script = "./db/metadata/${table}.sql"
            int errorCount = executeSqlScriptByLine(script)
            if (errorCount > 0) {
                throw new RuntimeException("The execution of $script encountered $errorCount error(s).")
            }
        }
    }

    printDataSourceConfig(dataSourceConfig)
    sql.close()

    log.info '---------- BuildDb.groovy: END -----------'
}

/**
 * Log the data source information.
 */
def printDataSourceConfig(ConfigObject dataSourceConfig) {
    log.info "Environment: ${Environment.current}, url=${dataSourceConfig.url}, username=${dataSourceConfig.username}, password=${dataSourceConfig.password}, driver=${dataSourceConfig.driverClassName}"
}

/**
 * Drop all schema objects.
 */
def dropAllObjects() {
    try {
        log.info 'Dropping all objects...'
        sql.call('{call purge_db_schema()}')
        log.info 'Dropping all objects done.'
    } catch (e) {
        log.error "dropAllObjects(): An exception occurred: ${e.message}"
    }
}

//
///**
// * Create foreign key indexes.
// */
//def createForeignKeyIndexes(String owner) {
//    try {
//        log.info 'Initializing foreign key index table...'
//        sql.call('{call p_init_fk_index_table(?)}', [owner])
//        log.info 'Initializing foreign key index table done.'
//        log.info 'Marking missing foreign key indexes...'
//        sql.call('{call p_mark_missing_fk_indexes(?)}', [owner])
//        log.info 'Marking missing foreign key indexes done.'
//        log.info 'Creating foreign key indexes...'
//        sql.call('{call p_create_fk_indexes()}')
//        log.info 'Creating foreign key indexes done.'
//    } catch (e) {
//        log.error "createForeignKeyIndexes(): An exception occurred: ${e.message}"
//    }
//}

/**
 * Execute a SQL script file, a single SQL statement at a time. The statements delimiter is the ';'.
 *
 * ATTENTION: THIS DOES NOT WORK IF THE STATEMENT CONTAINS A TEXT LITERAL THAT CONTAINS one or more ';'!
 * @param scriptFileName Script file to execute.
 * @return The number of errors encountered.
 */
int executeSqlScriptByStatement(String scriptFileName) {

    int count = 0 // SQL statements
    int countExecuted = 0 // SQL statements executed
    int errorCount = 0 // Error count

    log.info "Executing $scriptFileName ..."

    String ddl = new File(scriptFileName).text

    StringBuilder buffer = new StringBuilder()

    for (int i = 0; i < ddl.size(); i++) {
        if (ddl[i] == ';') {
            // Found semi-colon, execute the statement up to now.
            String sqlStatement = buffer.toString().trim()
            if (sqlStatement.startsWith('drop')) {
                log.debug "Skipping drop statement ($sqlStatement)"
            } else if (sqlStatement.startsWith('create table v_')) {
                log.debug "Skipping create statement for views ($sqlStatement)"
            } else if (sqlStatement.startsWith('alter table v_')) {
                log.debug "Skipping alter statement for views ($sqlStatement)"
            } else {
                log.trace "Execute: '${sqlStatement}'"
                try {
                    count++;
                    sql.execute(sqlStatement)
                    countExecuted++
                } catch (e) {
                    String errorMsg = "An exception occurred at offset ${i + 1} with statement '$sqlStatement': ${e.message}"
                    if (e.message.contains('ORA-01408: such column list already indexed') ||
                            e.message.contains('ORA-02261: such unique or primary key already exists in the table')) {
                        // Grails already has the unique or primary key, or index declared in its generated DDL script
                        log.warn errorMsg
                    } else {
                        errorCount++
                        log.error errorMsg
                        log.info "Proceeding..."
                    }
                }
            }

            // Reset buffer
            buffer.setLength(0)
        } else {
            buffer.append(ddl[i])
        }
    }

    log.info "Execution of $scriptFileName done: $countExecuted out of $count statements executed; $errorCount error(s) encountered."
    errorCount
}

/**
 * Execute a SQL Script assuming a line-by-line single statement execution.
 * Each line must be terminated by a ';'.
 * @param scriptFileName
 * @return
 */
int executeSqlScriptByLine(String scriptFileName) {

    int count = 0 // SQL statements executed
    int errorCount = 0 // Error count
    int lineCount = 0 // Line count

    log.info "Executing $scriptFileName ..."

    new File(scriptFileName).eachLine { String sqlStatement ->
        lineCount++
        log.trace "Processing: '$sqlStatement'..."
        sqlStatement = sqlStatement?.trim()
        if (sqlStatement && !sqlStatement.isEmpty()) {
            int len = sqlStatement.length()
            if (!sqlStatement.startsWith('--')) {
                // Not a comment

                // Remove the ending ';' as the Sql.execute() method does not like it for INSERT statement!?
                if (sqlStatement[len - 1] != ';') {
                    // Unexpected statement format
                    errorCount++
                    String errorMsg = "No ';' found at the end of the statement: '$sqlStatement'"
                    log.error errorMsg
                    log.info "Proceeding..."
                } else if (len < 2) {
                    // Seems to be an empty statement
                    String warnMsg = "Empty statement: '$sqlStatement'"
                    log.trace warnMsg
                    log.trace "Proceeding..."
                } else {
                    sqlStatement = sqlStatement[0..(len - 2)]
                    log.trace "Execute: '${sqlStatement}'"
                    try {
                        sql.execute(sqlStatement)
                        count++;
                    } catch (e) {
                        errorCount++
                        String errorMsg = "An exception occurred at line $lineCount with statement '$sqlStatement': ${e.message}"
                        log.error errorMsg
                        log.info "Proceeding..."
                    }
                }
            }
        }
    }

    log.info "Execution of $scriptFileName done: $count statements executed; $errorCount error(s) encountered."
    errorCount
}

/**
 * Create the Security ROLEs, as well as the SYSTEM account if it does not already exist.
 *
 * The SYSTEM account is used by the system only. The account is permanently locked, and cannot be logged in to.
 */
def createRolesAndSystemAccount() {
    GrailsApplication grailsApplication = ctx.grailsApplication
    assert grailsApplication != null
    SecurityService securityService = ctx.securityService
    assert securityService != null

    // Create the roles if they don't exist.
    def role = 'ROLE_SYSTEM'
    def systemRole = Role.findByAuthority(role)
    if (!systemRole) {
        systemRole = securityService.save(new Role(authority: role))
        log.info "Created role $systemRole"
    } else {
        log.info "Already created: Role $systemRole"
    }

    role = 'ROLE_ADMIN'
    def adminRole = Role.findByAuthority(role)
    if (!adminRole) {
        adminRole = securityService.save(new Role(authority: role))
        log.info "Created role $adminRole"
    } else {
        log.info "Already created: Role $adminRole"
    }

    role = 'ROLE_USER'
    def userRole = Role.findByAuthority(role)
    if (!userRole) {
        userRole = securityService.save(new Role(authority: role))
        log.info "Created role $userRole"
    } else {
        log.info "Already created: Role $userRole"
    }

    // System principal
    def username = 'system'
    def systemUser = User.findByUsername(username)
    if (!systemUser) {
        systemUser = new User(
                username: username,
                password: username, // The account is always locked, hence there is no login allowed.
                firstName: 'The',
                lastName: 'System',
                email: grailsApplication.config.ffars?.admin?.system?.email_address ?: 'tbd@tbd.com',
                accountLocked: true)
        if (!securityService.save(systemUser)) {
            throw new RuntimeException('Could not create the SYSTEM account!')
        } else {
            log.info "SYSTEM account created."
        }
        if (!securityService.save(new PrincipalRole(
                principal: systemUser,
                role: systemRole))) {
            throw new RuntimeException('Could not grant the ROLE_SYSTEM role to the SYSTEM account!')
        } else {
            log.info "SYSTEM account granted with the ROLE_SYSTEM role."
        }
    } else {
        log.info "SYSTEM account checked."
    }
}

/**
 * Load test users
 */
def createTestUsers() {

    log.info "---------- Create test users: BEGIN ----------"
    int roleCount = 0
    int userCount = 0

    SecurityService securityService = ctx.securityService
    assert securityService != null

    // Create the roles if they don't exist.
    def role = 'ROLE_ADMIN'
    def adminRole = Role.findByAuthority(role)
    if (!adminRole) {
        adminRole = securityService.save(new Role(authority: role))
        log.info "Created role $adminRole"
        roleCount++
    } else {
        log.info "Already created: Role $adminRole"
    }

    role = 'ROLE_USER'
    def userRole = Role.findByAuthority(role)
    if (!userRole) {
        userRole = securityService.save(new Role(authority: role))
        log.info "Created role $userRole"
        roleCount++
    } else {
        log.info "Already created: Role $userRole"
    }

    // Admin principal
    def username = 'admin'
    def adminUser = User.findByUsername(username)
    if (!adminUser) {
        securityService.saveWithRoles(
                new User(
                        username: username,
                        password: username,
                        firstName: 'The',
                        lastName: 'Administrator',
                        email: 'ffars_admin@epa.gov'),
                [userRole, adminRole])
        log.info "User $username created."
        userCount++
    } else {
        log.info "Already created: User $username"
    }

    username = 'rigaldiesb'
    userUser = User.findByUsername(username)
    if (!userUser) {
        securityService.saveWithRoles(
                new User(
                        username: username,
                        password: username,
                        firstName: 'Bertrand',
                        lastName: 'Rigaldies',
                        email: 'bertrand_rigaldies@sra.com'),
                [userRole, adminRole])
        log.info "User $username created."
        userCount++
    } else {
        log.info "Already created: User $username"
    }

    log.info "---------- Create test roles ($roleCount) and users ($userCount): END ----------"
}